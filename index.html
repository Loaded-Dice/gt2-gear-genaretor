<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GT2/GT3/GT4/GT5 Pulley Generator</title>
    <meta charset="utf-8">
    <script type="text/javascript">var switchTo5x = true;</script>
    <script type="text/javascript" src="//w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript" src="//s.sharethis.com/loader.js"></script>

    <meta property="og:url"           content="https://loaded-dice.github.io/gt2-gear-genaretor/" />
    <meta property="og:type"          content="website" />
    <meta property="og:title"         content="GT2/GT3/GT4/GT5 Pulley Generator" />
    <meta property="og:description"   content="Generate GT2, GT3, GT4, or GT5 pulley for laser cutter or download drawing" />
    <meta property="og:image"         content="https://loaded-dice.github.io/gt2-gear-genaretor/pict0.jpeg" />
    <meta property="og:image:url"     content="https://loaded-dice.github.io/gt2-gear-genaretor/pict0.jpeg" />

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:image" content="https://loaded-dice.github.io/gt2-gear-genaretor/pict0.jpeg"/>

    <meta name="Keywords" content="gt2 gt3 gt4 gt5 pulley generator, Timing, Pulley, Timing Belt, gear, g-code, dxf, generator, Pulley drawing, drawing, diy pulley">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 10px;
            background-color: #000000;
            overflow: hidden;
        }

        #display {
            width: 300px;
            height: 300px;
        }

        .settings {
            position: absolute;
            color: white;
        }

        .settings #params label {
            text-align: right;
        }

        .settings label {
            display: inline-block;
            width: 150px;
        }

        .settings input, .settings select {
            width: 100px;
        }

        #g-code {
            width: 200px;
            height: 100px;
        }
    </style>
</head>
<body>
<a href="https://github.com/Loaded-Dice/gt2-gear-genaretor"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
<div class="settings">
    <legend id="params">
        <label for="params">Settings</label>
        <div>
            <label>Pulley Type</label>
            <select onchange="changeParam('gerType', this);">
                <option value="2">GT2</option>
                <option value="3" selected>GT3</option>
                <option value="4">GT4</option>
                <option value="5">GT5</option>
            </select>
        </div>
        <div>
            <label>Number Of Teeth</label>
            <input type="number" placeholder="width" min="3" onchange="changeParam('numberOfTeeth',this);" value="50"/>
        </div>
        <div>
            <label>Central hole</label>
            <input type="number" placeholder="height" min="0" onchange="changeParam('centralHole',this);" value="3"/>
        </div>
        <div>
            <label>Number of radial holes</label>
            <input type="number" placeholder="height" min="0" onchange="changeParam('numberOfRadialRoles',this);" value="5"/>
        </div>
        <div>
            <label>Radial holes diameter</label>
            <input type="number" placeholder="height" min="0" onchange="changeParam('radialHolesdiameter',this);" value="3"/>
        </div>
        <div>
            <label>Radial holes distance</label>
            <input type="number" placeholder="height" min="0" onchange="changeParam('radialHolesDistance',this);" value="5"/>
        </div>
        <div>
            <label>Work Speed</label>
            <input onchange="changeParam('workSpeed',this);" type="number" min="0" placeholder="Work Speed" value="150"/>
        </div>
        <div>
            <label>Speed</label>
            <input onchange="changeParam('speed',this);" type="number" min="0" placeholder="Speed" value="400"/>
        </div>
        <div>
            <label>Laser Power</label>
            <input onchange="changeParam('laserPower',this);" type="number" min="0" placeholder="clamp" value="200"/>
        </div>
        <div>
            <label>Tool Offset</label>
            <input onchange="changeParam('toolOffset',this);" type="number" min="0" placeholder="Tool Offset" value="0"/>
        </div>
    </legend>
    <legend id="export">
        <label for="export">Export</label>
        <div>
            <button onclick="dataExport('dxf');">DXF</button>
            <button onclick="dataExport('g-code');">G code</button>
        </div>
        <textarea id="g-code"></textarea>
    </legend>
</div>
<script src="js/three.js"></script>
<script src="js/dxf.js"></script>
<script>
    var gtConstants = {
        '2': {
            'pitch': 2.0,
            'grooveDepth': 0.75,
            'pitchFactor': 0.40,
            'pld': 0.254,
            'insideDiameter': 0.555,
            'insideRoundDiameter': 1.0,
            'outsideRoundDiameter': 0.15
        },
        '3': {
            'pitch': 3.0,
            'grooveDepth': 1.14,
            'pitchFactor': 0.61,
            'pld': 0.381,
            'insideDiameter': 0.85,
            'insideRoundDiameter': 1.52,
            'outsideRoundDiameter': 0.255
        },
        '4': {
            'pitch': 4.0,
            'grooveDepth': 1.52,
            'pitchFactor': 0.813,
            'pld': 0.508,
            'insideDiameter': 1.133,
            'insideRoundDiameter': 2.027,
            'outsideRoundDiameter': 0.34
        },
        '5': {
            'pitch': 5.0,
            'grooveDepth': 1.93,
            'pitchFactor': 1.03,
            'pld': 0.5715,
            'insideDiameter': 1.40,
            'insideRoundDiameter': 2.57,
            'outsideRoundDiameter': 0.425
        }
    };

    var settings = {
        "version": 1,
        "toolOffset": 0.0,
        "numberOfTeeth": 50,
        "centralHole": 3,
        "numberOfRadialRoles": 5,
        "radialHolesdiameter": 3,
        "radialHolesDistance": 5,
        "workSpeed": 100,
        "speed": 400,
        "offset": 0,
        "laserPower": 200,
        "gerType": gtConstants['3'],
        "exportGear": true
    };

    var gearCenter = {x: 0, y: 0, z: 0};
    var shapes = [];
    var shapesForExport = [];
    var camera, scene, renderer;

    function changeParam(type, el) {
        if (type == "numberOfTeeth") {
            settings.numberOfTeeth = parseFloat(el.value);
        } else if (type == "centralHole") {
            settings.centralHole = parseFloat(el.value);
        } else if (type == "numberOfRadialRoles") {
            settings.numberOfRadialRoles = parseFloat(el.value);
        } else if (type == "radialHolesdiameter") {
            settings.radialHolesdiameter = parseFloat(el.value);
        } else if (type == "radialHolesDistance") {
            settings.radialHolesDistance = parseFloat(el.value);
        } else if (type == "workSpeed") {
            settings.workSpeed = parseFloat(el.value);
        } else if (type == "speed") {
            settings.speed = parseFloat(el.value);
        } else if (type == "laserPower") {
            settings.laserPower = parseFloat(el.value);
        } else if (type == "toolOffset") {
            settings.toolOffset = parseFloat(el.value);
        } else if (type == "gerType") {
            settings.gerType = gtConstants[el.value];
        }

        shapes.forEach(function (shape) {
            scene.remove(shape.line);
        });

        shapes = [];
        shapesForExport = [];
        if (settings.toolOffset > 0) {
            shapesForExport = makeGear(settings);
            settings.exportGear = false;
        }
        settings.toolOffset = 0;
        if (settings.exportGear) {
            window.location.hash = encodeURIComponent(JSON.stringify(settings));
            shapesForExport = makeGear(settings);
        } else {
            makeGear(settings);
        }
    }

    function degToRad(deg) {
        return (deg * Math.PI) / 180;
    }

    function radToDeg(rad) {
        return rad * 180 / Math.PI;
    }

    function distance(p1, p2) {
        if (!p1 || !p2) {
            console.warn('Undefined point in distance calculation');
            return 0;
        }
        var dx = p1.x - p2.x;
        var dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function vectorAngle(p1, p2) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
    }

    function pointToFixed(p) {
        var x = p.x;
        var y = p.y;
        return {'x': x.toFixed(3), 'y': y.toFixed(3)};
    }

    function dataExport(type) {
        textarea.value = "";
        var offsetX = 0;
        var offsetY = 0;
        var exporter = {};

        if (type == 'g-code') {
            exporter = gcodeExporter;
            textarea.value += "G90\n";
            textarea.value += "S" + settings.laserPower + "\n";
            shapesForExport.forEach(function (shape) {
                textarea.value += exporter[shape.type](shape, settings);
            });
            textarea.value += "G0 X0.000 Y0.000\n";
            textarea.value += "M2\n";
        } else if (type == 'dxf') {
            DxfExporter.reset();
            exporter = dxfExporterProxy;
            shapesForExport.forEach(function (shape) {
                exporter[shape.type](shape, settings);
            });
            textarea.value = DxfExporter.export();
        }
    }

    var textarea = document.getElementById('g-code');

    var gcodeExporter = {
        'circle': function (shape, settings) {
            var str = "";
            // Implement G-code for circle if needed
            return str;
        },
        'arc': function (shape, settings) {
            var str = "";
            // Implement G-code for arc if needed
            return str;
        }
    };

    var dxfExporterProxy = {
        'circle': function (shape) {
            DxfExporter.addCircle(shape.center, shape.radius);
        },
        'arc': function (shape) {
            DxfExporter.addArc(shape.center, shape.radius, shape.startAngle, shape.endAngle);
        }
    };

    function polar(center, angle, radius) {
        return {
            x: center.x + radius * Math.cos(degToRad(angle)),
            y: center.y + radius * Math.sin(degToRad(angle)),
            z: center.z || 0
        };
    }

    function triangleAnglesBySides(a, b, c) {
        if (a + b <= c || a + c <= b || b + c <= a) {
            console.warn('Invalid triangle sides: ' + a + ', ' + b + ', ' + c);
            return { a: 0, b: 0, c: 0, ba: 0, cb: 0 };
        }
        var cosA = (b * b + c * c - a * a) / (2 * b * c);
        var cosB = (a * a + c * c - b * b) / (2 * a * c);
        var cosC = (a * a + b * b - c * c) / (2 * a * b);
        return {
            a: radToDeg(Math.acos(cosA)),
            b: radToDeg(Math.acos(cosB)),
            c: radToDeg(Math.acos(cosC)),
            ba: radToDeg(Math.acos(cosB)),  // Assuming ba is angle B
            cb: radToDeg(Math.acos(cosC))   // cb is angle C
        };
    }

    function anglesBySideAndAngle(a, b, y) {
        var angle_2 = y;
        var side_1 = b;
        var side_2 = a;
        if (180 <= angle_2) {
            console.warn('Angle too large: ' + angle_2);
            return { a: 0, b: 0, c: 0 };
        } else {
            var cosAngle2 = Math.cos(degToRad(angle_2));
            var side_3 = Math.sqrt(side_2 * side_2 + side_1 * side_1 - 2 * side_2 * side_1 * cosAngle2);
            var cosAngle1 = (side_1 * side_1 + side_3 * side_3 - side_2 * side_2) / (2 * side_1 * side_3);
            var angle_1 = radToDeg(Math.acos(cosAngle1));
            var angle_3 = 180 - angle_2 - angle_1;
            return triangleAnglesBySides(b, a, side_3);
        }
    }

    function getInsideRoundPoint(angle, config, center, type) {
        var rootRadius = config.rootRadius;
        var outsideRadius = config.outsideRadius;
        var centerRadius = config.baseConfig.gerType.insideDiameter / 2;
        var hordDistance = outsideRadius - (rootRadius + centerRadius);
        if (hordDistance < 0) {
            console.warn('Negative hordDistance: ' + hordDistance);
            hordDistance = 0;
        }
        var pitchFactor = config.baseConfig.gerType.pitchFactor;
        var distSquared = hordDistance * hordDistance + pitchFactor * pitchFactor;
        var dist = Math.sqrt(distSquared);
        var angles = triangleAnglesBySides(hordDistance, dist, pitchFactor);
        var angleMargin = angles.a;  // Changed to a, as ba may be typo; test with b or c if needed
        var a = 0;
        if (type == 'l') {
            a = angle + angleMargin;
        } else if (type == 'r') {
            a = angle - angleMargin;
        }
        var point = polar(center, a, dist);
        point.sharedPoint = polar(center, a - 180, centerRadius - config.baseConfig.toolOffset);
        return { point: point, a: a };
    }

    function getOutsideRoundPoint(center, config, angle, type) {
        var insideRadius = config.baseConfig.gerType.insideRoundDiameter / 2;
        var outsideRadius = config.baseConfig.gerType.outsideRoundDiameter / 2;
        var sumRadius = insideRadius + outsideRadius;
        var angles = anglesBySideAndAngle(sumRadius, outsideRadius, 90);
        var angleMargin = angles.b;  // Changed to b; test with c if needed
        var a = 0;
        if (type == 'l') {
            a = angle + angleMargin;
        } else if (type == 'r') {
            a = angle - angleMargin;
        }
        var point = polar(center, a - 180, sumRadius);
        point.sharedPoint = polar(center, a - 180, insideRadius - config.baseConfig.toolOffset);
        point.edgeSharedPoint = polar(point, angle, outsideRadius + config.baseConfig.toolOffset);
        return point;
    }

    function addCircle(radius, center) {
        var circle = {
            'type': 'circle',
            'center': center,
            'radius': radius,
            'gcode': '',
            'path': [],
            'line': null,
            'material': new THREE.LineBasicMaterial({
                color: 0xFF0000
            })
        };
        var segments = 64;
        for (var i = 0; i <= segments; i++) {
            var theta = (i / segments) * Math.PI * 2;
            circle.path.push(polar(center, radToDeg(theta), radius));
        }
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(circle.path.length * 3), 3));
        var index = 0;
        for (var i = 0, l = circle.path.length; i < l; i++) {
            var positions = geometry.attributes.position.array;
            positions[index++] = circle.path[i].x;
            positions[index++] = circle.path[i].y;
            positions[index++] = circle.path[i].z || 0;
        }
        circle.line = new THREE.Line(geometry, circle.material);
        circle.line.rotation.x = degToRad(90);
        scene.add(circle.line);
        shapes.push(circle);
        return circle;
    }

    function addArc(from, to, radius) {
        var dist = distance(from, to);
        if (dist === 0) {
            console.warn('Skipping arc with zero distance');
            return null;
        }
        var type = radius > 0 ? 'l' : 'r';
        var arc = {
            'type': 'arc',
            'from': from,
            'to': to,
            'radius': radius,
            'gcode': '',
            'startAngle': 0,
            'endAngle': 0,
            'center': null,
            'geometry': new THREE.BufferGeometry(),
            'material': new THREE.LineBasicMaterial({
                color: 0xFF0000
            }),
            'path': [],
            'line': null
        };
        radius = Math.abs(radius);
        var angles = triangleAnglesBySides(radius, radius, dist);
        if (angles.a === 0 || isNaN(angles.a)) {
            console.warn('Invalid arc angles: minimum radius ' + (dist / 2) + ' given: ' + radius);
            return null;
        }
        var insideAngle = angles.a;  // Adjusted to a for inside angle
        var shiftAngle = angles.c;  // Adjusted
        var initAngle = vectorAngle(from, to);
        var direction = 0;
        if (type == "l") {
            direction = initAngle + shiftAngle;
        } else {
            direction = initAngle - shiftAngle;
        }
        arc.center = polar(from, direction, radius);
        if (type == "l") {
            arc.startAngle = vectorAngle(arc.center, from);
            arc.endAngle = vectorAngle(arc.center, to);
            var addodn = arc.startAngle;
            var step = insideAngle / 50;
            var current = insideAngle;
            arc.path.push(from);
            while (current >= 0) {
                arc.path.push(polar(arc.center, current + addodn, radius));
                current -= step;
            }
            arc.path.push(to);
        } else {
            arc.endAngle = vectorAngle(arc.center, from);
            arc.startAngle = vectorAngle(arc.center, to);
            var addodn = arc.startAngle;
            var i = 0;
            var step = insideAngle / 50;
            arc.path.push(from);
            while (i <= insideAngle) {
                arc.path.push(polar(arc.center, i + addodn, radius));
                i += step;
            }
            arc.path.push(to);
        }
        arc.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(arc.path.length * 3), 3));
        var index = 0;
        for (var i = 0, l = arc.path.length; i < l; i++) {
            var positions = arc.geometry.attributes.position.array;
            positions[index++] = arc.path[i].x;
            positions[index++] = arc.path[i].y;
            positions[index++] = arc.path[i].z || 0;
        }
        arc.line = new THREE.Line(arc.geometry, arc.material);
        arc.line.rotation.x = degToRad(90);
        scene.add(arc.line);
        shapes.push(arc);
        return arc;
    }

    function generateTeeth(shapesForExport, config, angle, nextteeth) {
        var roundRadius = config.baseConfig.gerType.insideDiameter / 2;
        var insideRoundRadius = config.baseConfig.gerType.insideRoundDiameter / 2;
        var outsideRoundRadius = config.baseConfig.gerType.outsideRoundDiameter / 2;

        var startPoint = polar(gearCenter, angle, config.rootRadius + (config.baseConfig.toolOffset));
        var teethCenter = polar(gearCenter, angle, (config.rootRadius + roundRadius));

        var leftInside = getInsideRoundPoint(angle, config, teethCenter, 'l');
        var rightInside = getInsideRoundPoint(angle, config, teethCenter, 'r');

        var leftOutside = getOutsideRoundPoint(leftInside.point, config, leftInside.a, 'l');
        var rightOutside = getOutsideRoundPoint(rightInside.point, config, rightInside.a, 'r');

        if (nextteeth) {
            var arc1 = addArc(leftOutside.edgeSharedPoint, leftOutside.sharedPoint, outsideRoundRadius + config.baseConfig.toolOffset);
            if (arc1) shapesForExport.push(arc1);
            var arc2 = addArc(leftOutside.sharedPoint, leftInside.sharedPoint, (insideRoundRadius - config.baseConfig.toolOffset) * -1);
            if (arc2) shapesForExport.push(arc2);
            var arc3 = addArc(leftInside.sharedPoint, startPoint, (roundRadius - config.baseConfig.toolOffset) * -1);
            if (arc3) shapesForExport.push(arc3);
            var arc4 = addArc(startPoint, rightInside.sharedPoint, (roundRadius - config.baseConfig.toolOffset) * -1);
            if (arc4) shapesForExport.push(arc4);
            var arc5 = addArc(rightInside.sharedPoint, rightOutside.sharedPoint, (insideRoundRadius - config.baseConfig.toolOffset) * -1);
            if (arc5) shapesForExport.push(arc5);
            var arc6 = addArc(rightOutside.sharedPoint, rightOutside.edgeSharedPoint, outsideRoundRadius + config.baseConfig.toolOffset);
            if (arc6) shapesForExport.push(arc6);
            var arc7 = addArc(rightOutside.edgeSharedPoint, nextteeth.start, config.outsideRadius + config.baseConfig.toolOffset);
            if (arc7) shapesForExport.push(arc7);
        }

        return {
            'start': leftOutside.edgeSharedPoint,
            'end': rightOutside.edgeSharedPoint,
            'leftOutside': leftOutside,
            'rightOutside': rightOutside,
            'leftInside': leftInside,
            'rightInside': rightInside
        };
    }

    function makeGear(settings) {
        var shapesForExport = [];
        var oneTeethAngle = (360 / settings.numberOfTeeth);
        var pitchRadius = (settings.numberOfTeeth * settings.gerType.pitch) / (Math.PI * 2);
        var pitchDiametr = pitchRadius * 2;
        var outsideDiameter = pitchDiametr - (settings.gerType.pld * 2);
        var outsideRadius = outsideDiameter / 2;
        var rootDiameter = outsideDiameter - (settings.gerType.grooveDepth * 2);
        var rootRadius = rootDiameter / 2;
        gearCenter.x = pitchRadius;
        gearCenter.y = pitchRadius;
        camera.position.x = pitchRadius;
        camera.position.y = -pitchRadius;
        var teethConfig = {
            "oneTeethAngle": oneTeethAngle,
            "pitchRadius": pitchRadius,
            "pitchDiametr": pitchDiametr,
            "outsideDiameter": outsideDiameter,
            "outsideRadius": outsideRadius,
            "rootDiameter": rootDiameter,
            "rootRadius": rootRadius,
            "baseConfig": settings
        };
        shapesForExport.push(addCircle((settings.centralHole - (settings.toolOffset * 2)) / 2, gearCenter));
        var teethAngle = 0;
        var nextTeeth;
        for (var i = 0; i < settings.numberOfTeeth;) {
            nextTeeth = generateTeeth(shapesForExport, teethConfig, teethAngle + oneTeethAngle);
            generateTeeth(shapesForExport, teethConfig, teethAngle, nextTeeth);
            teethAngle += oneTeethAngle;
            i++;
        }
        var holeAngle = 0;
        var radialHoleCenter;
        var oneholeAngle = 360 / settings.numberOfRadialRoles;
        if (settings.numberOfRadialRoles >= 2) {
            for (var i = 0; i < settings.numberOfRadialRoles; i++) {
                radialHoleCenter = polar(gearCenter, holeAngle, settings.radialHolesDistance);
                shapesForExport.push(addCircle((settings.radialHolesdiameter - (settings.toolOffset * 2)) / 2, radialHoleCenter));
                holeAngle += oneholeAngle;
            }
        }
        return shapesForExport;
    }

    function init() {
        if (window.location.hash.length > 1) {
            try {
                settings = JSON.parse(decodeURIComponent(window.location.hash.substring(1)));
            } catch (error) {
                console.log(error);
            }
        }
        camera = new THREE.PerspectiveCamera(7.2, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 400;
        camera.updateProjectionMatrix();
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = "display";
        document.body.appendChild(renderer.domElement);
        settings.toolOffset = 0;
        shapesForExport = makeGear(settings);
        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('wheel', onMouseWheel, false);
    }

    var fov = 1, zoom = 7.0;
    function onMouseWheel(e) {
        if (e.deltaY > 0) {
            zoom += 0.1;
        } else {
            zoom -= 0.1;
        }
        camera.fov = fov * zoom;
        camera.updateProjectionMatrix();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
    animate();
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
   }
</script>
<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-90392164-1', 'auto');
    ga('send', 'pageview');
</script>
<script id="help-ukraine-win" async="true" src="https://helpukrainewinwidget.org/cdn/widget.js?type=one&position=top-right&layout=main"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5891902795361a67"></script>
</body>
</html>
