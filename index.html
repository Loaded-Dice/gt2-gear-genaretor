<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GT2/GT3/GT4/GT5 Pulley Generator</title>
    <meta charset="utf-8">
    <script type="text/javascript">var switchTo5x = true;</script>
    <script type="text/javascript" src="//w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript" src="//s.sharethis.com/loader.js"></script>

    <meta property="og:url"           content="https://loaded-dice.github.io/gt2-gear-genaretor/" />
    <meta property="og:type"          content="website" />
    <meta property="og:title"         content="GT2/GT3/GT4/GT5 Pulley Generator" />
    <meta property="og:description"   content="Generate GT2, GT3, GT4, or GT5 pulley for laser cutter or download drawing" />
    <meta property="og:image"         content="https://loaded-dice.github.io/gt2-gear-genaretor/pict0.jpeg" />
    <meta property="og:image:url"     content="https://loaded-dice.github.io/gt2-gear-genaretor/pict0.jpeg" />

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:image" content="https://loaded-dice.github.io/gt2-gear-genaretor/pict0.jpeg"/>

    <meta name="Keywords" content="gt2 gt3 gt4 gt5 pulley generator, Timing, Pulley, Timing Belt, gear, g-code, dxf, generator, Pulley drawing, drawing, diy pulley">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 10px;
            background-color: #000000;
            overflow: hidden;
        }

        #display {
            width: 300px;
            height: 300px;
        }

        .settings {
            position: absolute;
            color: white;
        }

        .settings #params label {
            text-align: right;
        }

        .settings label {
            display: inline-block;
            width: 150px;
        }

        .settings input, .settings select {
            width: 100px;
        }

        #g-code {
            width: 200px;
            height: 100px;
        }
    </style>
</head>
<body>
<a href="https://github.com/Loaded-Dice/gt2-gear-genaretor"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
<div class="settings">
    <legend id="params">
        <label for="params">Settings</label>
        <div>
            <label>Pulley Type</label>
            <select onchange="changeParam('gerType', this);">
                <option value="2">GT2</option>
                <option value="3" selected>GT3</option>
                <option value="4">GT4</option>
                <option value="5">GT5</option>
            </select>
        </div>
        <div>
            <label>Number Of Teeth</label>
            <input type="number" placeholder="width" min="3" onchange="changeParam('numberOfTeeth',this);" value="50"/>
        </div>
        <div>
            <label>Central hole</label>
            <input type="number" placeholder="height" min="0" onchange="changeParam('centralHole',this);" value="3"/>
        </div>
        <div>
            <label>Number of radial holes</label>
            <input type="number" placeholder="height" min="0" onchange="changeParam('numberOfRadialRoles',this);" value="5"/>
        </div>
        <div>
            <label>Radial holes diameter</label>
            <input type="number" placeholder="height" min="0" onchange="changeParam('radialHolesdiameter',this);" value="3"/>
        </div>
        <div>
            <label>Radial holes distance</label>
            <input type="number" placeholder="height" min="0" onchange="changeParam('radialHolesDistance',this);" value="5"/>
        </div>
        <div>
            <label>Work Speed</label>
            <input onchange="changeParam('workSpeed',this);" type="number" min="0" placeholder="Work Speed" value="150"/>
        </div>
        <div>
            <label>Speed</label>
            <input onchange="changeParam('speed',this);" type="number" min="0" placeholder="Speed" value="400"/>
        </div>
        <div>
            <label>Laser Power</label>
            <input onchange="changeParam('laserPower',this);" type="number" min="0" placeholder="clamp" value="200"/>
        </div>
        <div>
            <label>Tool Offset</label>
            <input onchange="changeParam('toolOffset',this);" type="number" min="0" placeholder="Tool Offset" value="0"/>
        </div>
    </legend>
    <legend id="export">
        <label for="export">Export</label>
        <div>
            <button onclick="dataExport('dxf');">DXF</button>
            <button onclick="dataExport('g-code');">G code</button>
        </div>
        <textarea id="g-code"></textarea>
    </legend>
</div>
<script src="js/three.js"></script>
<script src="js/dxf.js"></script>
<script>
    var gtConstants = {
        '2': {
            'pitch': 2.0,
            'grooveDepth': 0.75,
            'pitchFactor': 0.40,
            'pld': 0.254,
            'insideDiameter': 0.555,
            'insideRoundDiameter': 1.0,
            'outsideRoundDiameter': 0.15
        },
        '3': {
            'pitch': 3.0,
            'grooveDepth': 1.14,
            'pitchFactor': 0.61,
            'pld': 0.381,
            'insideDiameter': 0.85,
            'insideRoundDiameter': 1.52,
            'outsideRoundDiameter': 0.255
        },
        '4': {
            'pitch': 4.0,
            'grooveDepth': 1.52,
            'pitchFactor': 0.813, // Angepasst, um zero-distance zu vermeiden
            'pld': 0.508,
            'insideDiameter': 1.133,
            'insideRoundDiameter': 2.027,
            'outsideRoundDiameter': 0.34
        },
        '5': {
            'pitch': 5.0,
            'grooveDepth': 1.93,
            'pitchFactor': 1.03,
            'pld': 0.5715,
            'insideDiameter': 1.40,
            'insideRoundDiameter': 2.57,
            'outsideRoundDiameter': 0.425
        }
    };

    var settings = {
        "version": 1,
        "toolOffset": 0.0,
        "numberOfTeeth": 50,
        "centralHole": 3,
        "numberOfRadialRoles": 5,
        "radialHolesdiameter": 3,
        "radialHolesDistance": 5,
        "workSpeed": 100,
        "speed": 400,
        "offset": 0,
        "laserPower": 200,
        "gerType": gtConstants['3'],
        "exportGear": true
    };

    var gearCenter = {x: 0, y: 0, z: 0};
    var shapes = [];
    var shapesForExport = [];
    var camera, scene, renderer;

    function changeParam(type, el) {
        if (type == "numberOfTeeth") {
            settings.numberOfTeeth = parseFloat(el.value);
        } else if (type == "centralHole") {
            settings.centralHole = parseFloat(el.value);
        } else if (type == "numberOfRadialRoles") {
            settings.numberOfRadialRoles = parseFloat(el.value);
        } else if (type == "radialHolesdiameter") {
            settings.radialHolesdiameter = parseFloat(el.value);
        } else if (type == "radialHolesDistance") {
            settings.radialHolesDistance = parseFloat(el.value);
        } else if (type == "workSpeed") {
            settings.workSpeed = parseFloat(el.value);
        } else if (type == "speed") {
            settings.speed = parseFloat(el.value);
        } else if (type == "laserPower") {
            settings.laserPower = parseFloat(el.value);
        } else if (type == "toolOffset") {
            settings.toolOffset = parseFloat(el.value);
        } else if (type == "gerType") {
            settings.gerType = gtConstants[el.value];
        }

        shapes.forEach(function (shape) {
            scene.remove(shape.line);
        });

        shapes = [];
        shapesForExport = [];
        if (settings.toolOffset > 0) {
            shapesForExport = makeGear(settings);
            settings.exportGear = false;
        }
        settings.toolOffset = 0;
        if (settings.exportGear) {
            window.location.hash = encodeURIComponent(JSON.stringify(settings));
            shapesForExport = makeGear(settings);
        } else {
            makeGear(settings);
        }
    }

    function degToRad(angle) {
        return (angle * Math.PI) / 180;
    }

    function distance(p1, p2) {
        if (!p1 || !p2 || p1.x === undefined || p1.y === undefined || p2.x === undefined || p2.y === undefined) {
            console.warn('Undefined point in distance calculation');
            return 0; // Vermeide NaN, return 0 für skip
        }
        var dx = p1.x - p2.x;
        var dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function vectorAngle(p1, p2) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
    }

    function pointToFixed(p) {
        var x = p.x;
        var y = p.y;
        return {'x': x.toFixed(3), 'y': y.toFixed(3)};
    }

    function dataExport(type) {
        textarea.value = "";
        var offsetX = 0;
        var offsetY = 0;
        var exporter = {};

        if (type == 'g-code') {
            exporter = gcodeExporter;
            textarea.value += "G90\n";
            textarea.value += "S" + settings.laserPower + "\n";
            shapesForExport.forEach(function (shape) {
                textarea.value += exporter[shape.type](shape, settings);
            });
            textarea.value += "G0 X0.000 Y0.000\n";
            textarea.value += "M2\n";
        } else if (type == 'dxf') {
            DxfExporter.reset();
            exporter = dxfExporterProxy;
            shapesForExport.forEach(function (shape) {
                exporter[shape.type](shape, settings);
            });
            textarea.value = DxfExporter.export();
        }
    }

    var textarea = document.getElementById('g-code');

    var gcodeExporter = {
        'circle': function (shape, settings) {
            var str = "G0 X" + shape.center.x.toFixed(3) + " Y" + shape.center.y.toFixed(3) + "\n";
            str += "M3\n";
            var first = true;
            shape.path.forEach(function (point) {
                if (first) {
                    str += "G1 X" + point.x.toFixed(3) + " Y" + point.y.toFixed(3) + " F" + settings.workSpeed + "\n";
                    first = false;
                } else {
                    str += "G1 X" + point.x.toFixed(3) + " Y" + point.y.toFixed(3) + "\n";
                }
            });
            str += "M5\n";
            return str;
        },
        'arc': function (shape, settings) {
            var str = "G0 X" + shape.from.x.toFixed(3) + " Y" + shape.from.y.toFixed(3) + "\n";
            str += "M3\n";
            shape.path.forEach(function (point) {
                str += "G1 X" + point.x.toFixed(3) + " Y" + point.y.toFixed(3) + "\n";
            });
            str += "M5\n";
            return str;
        }
    };

    var dxfExporterProxy = {
        'circle': function (shape, settings) {
            DxfExporter.addCircle(shape.center, shape.radius);
        },
        'arc': function (shape, settings) {
            DxfExporter.addArc(shape.center, shape.radius, shape.startAngle, shape.endAngle);
        }
    };

    function addCircle(radius, center) {
        var circle = {
            'type': 'circle',
            'center': center,
            'radius': radius,
            'path': [],
            'line': null,
            'material': new THREE.LineBasicMaterial({
                color: 0xFF0000
            })
        };
        var segments = 64;
        for (var i = 0; i <= segments; i++) {
            var theta = (i / segments) * Math.PI * 2;
            circle.path.push({
                x: center.x + radius * Math.cos(theta),
                y: center.y + radius * Math.sin(theta),
                z: center.z || 0
            });
        }
        var geometry = new THREE.BufferGeometry();
        var positions = new Float32Array(circle.path.length * 3);
        circle.path.forEach((p, index) => {
            positions[index * 3] = p.x;
            positions[index * 3 + 1] = p.y;
            positions[index * 3 + 2] = p.z;
        });
        geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        circle.line = new THREE.Line(geometry, circle.material);
        circle.line.rotation.x = degToRad(90);
        scene.add(circle.line);
        shapes.push(circle);
        return circle;
    }

    function addArc(from, to, radius) {
        var dist = distance(from, to);
        if (dist === 0) {
            console.warn('Skipping arc with zero distance');
            return null;
        }
        var type = radius > 0 ? 'l' : 'r';
        var arc = {
            'type': 'arc',
            'from': from,
            'to': to,
            'radius': radius,
            'startAngle': 0,
            'endAngle': 0,
            'center': null,
            'geometry': new THREE.BufferGeometry(),
            'material': new THREE.LineBasicMaterial({
                color: 0xFF0000
            }),
            'path': [],
            'line': null
        };
        radius = Math.abs(radius);
        var angles = triangleAnglesBySides(radius, radius, dist);
        if (angles.ac == 0 || isNaN(angles.ac)) {
            console.warn('Invalid arc angles, skipping');
            return null;
        }
        var insideAngle = angles.ba;
        var shiftAngle = angles.ac;
        var initAngle = vectorAngle(from, to);
        var direction = type == "l" ? initAngle + shiftAngle : initAngle - shiftAngle;
        arc.center = polar(from, direction, radius);
        if (type == "l") {
            arc.startAngle = vectorAngle(arc.center, from);
            arc.endAngle = vectorAngle(arc.center, to);
            var addodn = arc.startAngle;
            var step = insideAngle / 100; // Mehr Schritte für glattere Arcs
            for (var i = insideAngle; i >= 0; i -= step) {
                arc.path.push(polar(arc.center, i + addodn, radius));
            }
        } else {
            arc.endAngle = vectorAngle(arc.center, from);
            arc.startAngle = vectorAngle(arc.center, to);
            var addodn = arc.startAngle;
            var step = insideAngle / 100;
            for (var i = 0; i <= insideAngle; i += step) {
                arc.path.push(polar(arc.center, i + addodn, radius));
            }
        }
        var positions = new Float32Array(arc.path.length * 3);
        arc.path.forEach((p, index) => {
            positions[index * 3] = p.x;
            positions[index * 3 + 1] = p.y;
            positions[index * 3 + 2] = p.z || 0;
        });
        arc.geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        arc.line = new THREE.Line(arc.geometry, arc.material);
        arc.line.rotation.x = degToRad(90);
        scene.add(arc.line);
        shapes.push(arc);
        return arc;
    }

    function polar(center, angle, radius) {
        return {
            x: center.x + radius * Math.cos(degToRad(angle)),
            y: center.y + radius * Math.sin(degToRad(angle)),
            z: center.z || 0
        };
    }

    function triangleAnglesBySides(a, b, c) {
        var cosA = (b * b + c * c - a * a) / (2 * b * c);
        var cosB = (a * a + c * c - b * b) / (2 * a * c);
        var cosC = (a * a + b * b - c * c) / (2 * a * b);
        return {
            a: Math.acos(cosA) * 180 / Math.PI,
            b: Math.acos(cosB) * 180 / Math.PI,
            c: Math.acos(cosC) * 180 / Math.PI
        };
    }

    function getInsideRoundPoint(angle, config, teethCenter, side) {
        var insideRoundRadius = config.baseConfig.gerType.insideRoundDiameter / 2;
        var angleOffset = (config.oneTeethAngle * config.baseConfig.gerType.pitchFactor) / 2;
        var point = polar(teethCenter, side === 'l' ? angle - angleOffset : angle + angleOffset, insideRoundRadius);
        var sharedPoint = polar(point, side === 'l' ? angle - angleOffset : angle + angleOffset, insideRoundRadius - config.baseConfig.toolOffset);
        var edgeAngle = side === 'l' ? angle - angleOffset - 90 : angle + angleOffset + 90;
        var edgeSharedPoint = polar(point, edgeAngle, insideRoundRadius - config.baseConfig.toolOffset);
        return {
            point: point,
            a: side === 'l' ? angle - angleOffset : angle + angleOffset,
            sharedPoint: sharedPoint,
            edgeSharedPoint: edgeSharedPoint
        };
    }

    function getOutsideRoundPoint(point, config, angle, side) {
        var outsideRoundRadius = config.baseConfig.gerType.outsideRoundDiameter / 2;
        var sharedPoint = polar(point, angle, outsideRoundRadius + config.baseConfig.toolOffset);
        var edgeAngle = side === 'l' ? angle + 90 : angle - 90;
        var edgeSharedPoint = polar(point, edgeAngle, outsideRoundRadius + config.baseConfig.toolOffset);
        return {
            sharedPoint: sharedPoint,
            edgeSharedPoint: edgeSharedPoint
        };
    }

    function generateTeeth(shapesForExport, config, angle, nextteeth) {
        var roundRadius = config.baseConfig.gerType.insideDiameter / 2;
        var insideRoundRadius = config.baseConfig.gerType.insideRoundDiameter / 2;
        var outsideRoundRadius = config.baseConfig.gerType.outsideRoundDiameter / 2;

        var startPoint = polar(gearCenter, angle, config.rootRadius + config.baseConfig.toolOffset);
        var teethCenter = polar(gearCenter, angle, config.rootRadius + roundRadius);

        var leftInside = getInsideRoundPoint(angle, config, teethCenter, 'l');
        var rightInside = getInsideRoundPoint(angle, config, teethCenter, 'r');

        var leftOutside = getOutsideRoundPoint(leftInside.point, config, leftInside.a, 'l');
        var rightOutside = getOutsideRoundPoint(rightInside.point, config, rightInside.a, 'r');

        if (nextteeth) {
            var arc1 = addArc(leftOutside.edgeSharedPoint, leftOutside.sharedPoint, outsideRoundRadius + config.baseConfig.toolOffset);
            if (arc1) shapesForExport.push(arc1);
            var arc2 = addArc(leftOutside.sharedPoint, leftInside.sharedPoint, - (insideRoundRadius - config.baseConfig.toolOffset));
            if (arc2) shapesForExport.push(arc2);
            var arc3 = addArc(leftInside.sharedPoint, startPoint, - (roundRadius - config.baseConfig.toolOffset));
            if (arc3) shapesForExport.push(arc3);
            var arc4 = addArc(startPoint, rightInside.sharedPoint, - (roundRadius - config.baseConfig.toolOffset));
            if (arc4) shapesForExport.push(arc4);
            var arc5 = addArc(rightInside.sharedPoint, rightOutside.sharedPoint, - (insideRoundRadius - config.baseConfig.toolOffset));
            if (arc5) shapesForExport.push(arc5);
            var arc6 = addArc(rightOutside.sharedPoint, rightOutside.edgeSharedPoint, outsideRoundRadius + config.baseConfig.toolOffset);
            if (arc6) shapesForExport.push(arc6);
            var arc7 = addArc(rightOutside.edgeSharedPoint, nextteeth.start, config.outsideRadius + config.baseConfig.toolOffset);
            if (arc7) shapesForExport.push(arc7);
        }

        return {
            'start': leftOutside.edgeSharedPoint,
            'end': rightOutside.edgeSharedPoint
        };
    }

    function makeGear(settings) {
        var shapesForExport = [];
        var oneTeethAngle = 360 / settings.numberOfTeeth;
        var pitchRadius = (settings.numberOfTeeth * settings.gerType.pitch) / (Math.PI * 2);
        var pitchDiametr = pitchRadius * 2;
        var outsideDiameter = pitchDiametr - (settings.gerType.pld * 2);
        var outsideRadius = outsideDiameter / 2;
        var rootDiameter = outsideDiameter - (settings.gerType.grooveDepth * 2);
        var rootRadius = rootDiameter / 2;
        gearCenter.x = pitchRadius;
        gearCenter.y = pitchRadius;
        camera.position.x = pitchRadius;
        camera.position.y = -pitchRadius;
        var teethConfig = {
            "oneTeethAngle": oneTeethAngle,
            "pitchRadius": pitchRadius,
            "pitchDiametr": pitchDiametr,
            "outsideDiameter": outsideDiameter,
            "outsideRadius": outsideRadius,
            "rootDiameter": rootDiameter,
            "rootRadius": rootRadius,
            "baseConfig": settings
        };
        shapesForExport.push(addCircle((settings.centralHole - (settings.toolOffset * 2)) / 2, gearCenter));
        var teethAngle = 0;
        var nextTeeth = null;
        for (var i = 0; i < settings.numberOfTeeth; i++) {
            nextTeeth = generateTeeth(shapesForExport, teethConfig, teethAngle + oneTeethAngle, null); // Erste ohne next
            generateTeeth(shapesForExport, teethConfig, teethAngle, nextTeeth);
            teethAngle += oneTeethAngle;
        }
        var holeAngle = 0;
        var radialHoleCenter;
        var oneholeAngle = 360 / settings.numberOfRadialRoles;
        if (settings.numberOfRadialRoles >= 2) {
            for (var i = 0; i < settings.numberOfRadialRoles; i++) {
                radialHoleCenter = polar(gearCenter, holeAngle, settings.radialHolesDistance);
                shapesForExport.push(addCircle((settings.radialHolesdiameter - (settings.toolOffset * 2)) / 2, radialHoleCenter));
                holeAngle += oneholeAngle;
            }
        }
        return shapesForExport;
    }

    function init() {
        if (window.location.hash.length > 1) {
            try {
                settings = JSON.parse(decodeURIComponent(window.location.hash.substring(1)));
            } catch (error) {
                console.log(error);
            }
        }
        camera = new THREE.PerspectiveCamera(7.2, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 400;
        camera.updateProjectionMatrix();
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = "display";
        document.body.appendChild(renderer.domElement);
        settings.toolOffset = 0;
        shapesForExport = makeGear(settings);
        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('wheel', onMouseWheel, false);
    }

    var fov = 1, zoom = 7.0;
    function onMouseWheel(e) {
        if (e.deltaY > 0) {
            zoom += 0.1;
        } else {
            zoom -= 0.1;
        }
        camera.fov = fov * zoom;
        camera.updateProjectionMatrix();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
    animate();
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
   }
</script>
<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-90392164-1', 'auto');
    ga('send', 'pageview');
</script>
<script id="help-ukraine-win" async="true" src="https://helpukrainewinwidget.org/cdn/widget.js?type=one&position=top-right&layout=main"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5891902795361a67"></script>
</body>
</html>
